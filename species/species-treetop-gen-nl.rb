#!/usr/bin/env ruby
#
# Generate treetop fish species grammar from regular fish names on standard input.
#
# Many fishes can be prefixed by a sea or ocean name. To reduce size and increase
# matches, we remove the areas when reading, and allow them to be optionally present
# in the grammar. The same is done for colors.
#
# Note that the order of items is relevant, because Treetop is a greedy non-backtracking
# parser. Put the longest item first, so that we get +'groene' / 'groen'+ instead of the
# other way around.
#
require 'set'
require 'date'

names = Set.new

areas = %w(
  atlantische alaska argentijnse groenlandse indische pacifische
).sort_by(&:length).reverse
attrs = %w(
  witte wit rood rode roze blauwe blauw groene groen zwarte zwart
  coho doorn chum
).sort_by(&:length).reverse
suffixes = %w(
  filets filet
)

names = Set.new

STDIN.each_line(chomp: true) do |line|
  name = line.strip.downcase
  name.gsub!(/\A#{Regexp.union(areas.map(&Regexp.method(:escape)))}/, '')
  name.gsub!(/\A#{Regexp.union(attrs.map(&Regexp.method(:escape)))}/, '')
  name.gsub!(/#{Regexp.union(suffixes.map(&Regexp.method(:escape)))}\z/, '')
  names.add(name.strip)
end

puts <<EOF
# autogenerated by #{File.basename(__FILE__)} on #{Date.today}
module FoodFishParser::Grammar
  grammar FishNameNL
    include Common

    rule fish_name_nl
      ( fish_name_nl_area ws+ )? ( fish_name_nl_attr ws* )? fish_name_nl_name fish_name_nl_suffix?
      <FishNameCommonNode>
    end

    rule fish_name_nl_area
      #{areas.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end

    rule fish_name_nl_attr
      #{attrs.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end

    rule fish_name_nl_name
      #{names.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end

    rule fish_name_nl_suffix
      #{suffixes.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end
  end
end
EOF
