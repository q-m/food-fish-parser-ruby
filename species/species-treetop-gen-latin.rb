#!/usr/bin/env ruby
#
# Generate treetop fish species grammar from latin species names on standard input.
#
# We use this as a poor man's named entity recognition (NER), to reduce size the first
# and second name are separated and included separately.
#
# Note that the order of items is relevant, because Treetop is a greedy non-backtracking
# parser. Put the longest item first, so that we get +'groene' / 'groen'+ instead of the
# other way around.
#
require 'set'
require 'date'

names_first = Set.new
names_second = Set.new

STDIN.each_line(chomp: true) do |line|
  line.gsub!(/\s*#.*\z/, '')   # remove comments
  line.downcase!
  line.strip!
  next if line == ''

  first, second = line.split(/\s+/, 2)
  # 'alle' is too generic, we only want to detect 'alle alle'
  # 'octopus' is also too generic, only detect full genus
  first, second = line, nil if ['alle', 'octopus'].include?(first)
  # also don't split lines with bracket
  first, second = line, nil if line =~ /\(.+?\)/

  names_first.add(first)
  names_second.add(second) if second
end

# include "species pluralis", with and without dot
names_second.add('spp')
names_second.add('spp.')

if ARGV[0] == 'strict'
puts <<EOF
# autogenerated by #{File.basename(__FILE__)} on #{Date.today}
module FoodFishParser::Strict::Grammar
  grammar FishNameLatin
    include Common
    include FishAllergen

    rule fish_name_latin
      '(' ws* fish_name_latin ws* ')' /
      fish_name_latin_first ( ws+ fish_name_latin_second )?
      ( ws* fish_allergen )?
      <FishNameLatinNode>
    end

    rule fish_name_latin_first
      #{names_first.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end

    rule fish_name_latin_second
      #{names_second.sort.reverse.map {|s| "'#{s}'i" }.join(" / ")}
    end
  end
end
EOF

elsif ARGV[0] == 'flat'
puts <<EOF
# autogenerated by #{File.basename(__FILE__)} on #{Date.today}
module FoodFishParser
  module Flat
    module FishNameLatin
      REGEX_FIRST = /#{names_first.sort.reverse.map {|s| Regexp.escape(s) }.join("|")}/i
      REGEX_SECND = /#{names_second.sort.reverse.map {|s| Regexp.escape(s) }.join("|")}/i

      REGEX = /
        \\b
        (
          \#{REGEX_FIRST} (?: \\s+ \#{REGEX_SECND} )?
        )
        \\b
      /ix
    end
  end
end
EOF

else
STDERR.puts "Please give 'strict' or 'flat' as argument."

end
